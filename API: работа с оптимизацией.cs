// запускает оптимизацию на выбранном скрипте, запуск осуществляется только в том случае
// если скрипт открыт в ТСЛаб
// bool - возвращает True если оптимизацию успешно запущена, если скрипт закрыт, возвращает False
bool Сontext.StartOptimization(string scriptName, string optimizationMethodName){}

// ставит оптимизацию на паузу на выбранном скрипте, постановка на паузу осуществляется только в том случае
// если скрипт открыт в ТСЛаб
// bool - возвращает True если оптимизация поставлена на паузу, если скрипт закрыт, возвращает False
bool Сontext.PauseOptimization(string scriptName){}

// останавливает оптимизацию на выбранном скрипте, остановка осуществляется только в том случае
// если скрипт открыт в ТСЛаб
// bool - возвращает True если оптимизация остановлена, если скрипт закрыт, возвращает False
bool Сontext.StopOptimization(string scriptName){}

// возвращает коллекцию имен методов оптимизации
IEnumerable<string> Context.GetOptimizationMethodsInfo(){}

// возвращает текущий статус оптимизации указанного скрипта
IEnumerable<(string scriptName, OptimizationStatus optimizationStatus)> Context.GetOptimizationsInfo(){}

enum OptimizationStatus 
{
  Running, // оптимизация в процессе работы
  Finished, // оптимизация удачно завершена
  Paused, // оптимизация на паузе
  StoppedManually, // оптимизация принудительно остановлена
  StoppedWithError, // оптимизация остановлена по наличию ошибки
  NotStarted // оптимизация не запускалась после открытия скрипта
}

/* можно было бы еще разные события сделать с подпиской на них, но это уже имхо лишние сложности, достаточно
  наличия нескольких методов, которые можно вызывать в любой точке оптимизации, чтобы понять текущее состояние 
  процесса оптимизации */
